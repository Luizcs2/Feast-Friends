# ---- Build Stage (Stage 1) ----
# We use a "multi-stage build" to keep the final image small.
# This first stage, named "builder", has all the Go tools needed to compile the code.
FROM golang:1.22-alpine AS builder

# Set the working directory inside the container.
# All subsequent commands will run from this path.
WORKDIR /app

# Copy the dependency management files.
# We copy these first to take advantage of Docker's layer caching.
# If these files don't change, Docker won't re-download dependencies on every build.
COPY go.mod go.sum ./
RUN go mod download

# Copy the rest of your application's source code into the container.
COPY . .

# Compile the Go application.
# - CGO_ENABLED=0 creates a statically linked binary, which means it has no external dependencies.
#   This is crucial for running it in a minimal container like 'alpine'.
# - GOOS=linux ensures the binary is compiled for a Linux operating system (which Docker containers use).
# - -o /main specifies the output file name and location for the compiled program.
# - ./cmd/api/ is the path to your main package. CHANGE THIS if your main.go is elsewhere.
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o /main ./cmd/api/


# ---- Final Stage (Stage 2) ----
# This stage builds the final, lightweight image that will be deployed.
# It starts from a minimal base image that doesn't contain any Go tooling.
FROM alpine:latest

# Set the working directory for the final container.
WORKDIR /root/

# Copy ONLY the compiled binary from the "builder" stage.
# This is the key step of a multi-stage build. We're not copying any source code
# or build tools, which makes the final image very small and secure.
COPY --from=builder /main .

# Inform Docker that the container listens on the specified network port at runtime.
# Your application code must actually listen on this port.
EXPOSE 8080

# The command to execute when the container starts.
# This runs the compiled Go application.
CMD ["./main"]